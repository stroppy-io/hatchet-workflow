// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: hatchet/tasks.proto

package hatchet

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Provisioner_ProvisionCloud_FullMethodName = "/hatchet.Provisioner/ProvisionCloud"
	Provisioner_RemoveCloud_FullMethodName    = "/hatchet.Provisioner/RemoveCloud"
)

// ProvisionerClient is the client API for Provisioner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProvisionerClient interface {
	ProvisionCloud(ctx context.Context, in *ProvisionCloudRequest, opts ...grpc.CallOption) (*ProvisionCloudResponse, error)
	RemoveCloud(ctx context.Context, in *ProvisionCloudRequest, opts ...grpc.CallOption) (*ProvisionCloudResponse, error)
}

type provisionerClient struct {
	cc grpc.ClientConnInterface
}

func NewProvisionerClient(cc grpc.ClientConnInterface) ProvisionerClient {
	return &provisionerClient{cc}
}

func (c *provisionerClient) ProvisionCloud(ctx context.Context, in *ProvisionCloudRequest, opts ...grpc.CallOption) (*ProvisionCloudResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProvisionCloudResponse)
	err := c.cc.Invoke(ctx, Provisioner_ProvisionCloud_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerClient) RemoveCloud(ctx context.Context, in *ProvisionCloudRequest, opts ...grpc.CallOption) (*ProvisionCloudResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProvisionCloudResponse)
	err := c.cc.Invoke(ctx, Provisioner_RemoveCloud_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProvisionerServer is the server API for Provisioner service.
// All implementations must embed UnimplementedProvisionerServer
// for forward compatibility.
type ProvisionerServer interface {
	ProvisionCloud(context.Context, *ProvisionCloudRequest) (*ProvisionCloudResponse, error)
	RemoveCloud(context.Context, *ProvisionCloudRequest) (*ProvisionCloudResponse, error)
	mustEmbedUnimplementedProvisionerServer()
}

// UnimplementedProvisionerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProvisionerServer struct{}

func (UnimplementedProvisionerServer) ProvisionCloud(context.Context, *ProvisionCloudRequest) (*ProvisionCloudResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProvisionCloud not implemented")
}
func (UnimplementedProvisionerServer) RemoveCloud(context.Context, *ProvisionCloudRequest) (*ProvisionCloudResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCloud not implemented")
}
func (UnimplementedProvisionerServer) mustEmbedUnimplementedProvisionerServer() {}
func (UnimplementedProvisionerServer) testEmbeddedByValue()                     {}

// UnsafeProvisionerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProvisionerServer will
// result in compilation errors.
type UnsafeProvisionerServer interface {
	mustEmbedUnimplementedProvisionerServer()
}

func RegisterProvisionerServer(s grpc.ServiceRegistrar, srv ProvisionerServer) {
	// If the following call pancis, it indicates UnimplementedProvisionerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Provisioner_ServiceDesc, srv)
}

func _Provisioner_ProvisionCloud_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvisionCloudRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServer).ProvisionCloud(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Provisioner_ProvisionCloud_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServer).ProvisionCloud(ctx, req.(*ProvisionCloudRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Provisioner_RemoveCloud_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvisionCloudRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServer).RemoveCloud(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Provisioner_RemoveCloud_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServer).RemoveCloud(ctx, req.(*ProvisionCloudRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Provisioner_ServiceDesc is the grpc.ServiceDesc for Provisioner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Provisioner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hatchet.Provisioner",
	HandlerType: (*ProvisionerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProvisionCloud",
			Handler:    _Provisioner_ProvisionCloud_Handler,
		},
		{
			MethodName: "RemoveCloud",
			Handler:    _Provisioner_RemoveCloud_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hatchet/tasks.proto",
}

const (
	Installer_InstallPostgres_FullMethodName = "/hatchet.Installer/InstallPostgres"
	Installer_InstallStroppy_FullMethodName  = "/hatchet.Installer/InstallStroppy"
)

// InstallerClient is the client API for Installer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstallerClient interface {
	InstallPostgres(ctx context.Context, in *InstallPostgresParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	InstallStroppy(ctx context.Context, in *InstallStroppyParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type installerClient struct {
	cc grpc.ClientConnInterface
}

func NewInstallerClient(cc grpc.ClientConnInterface) InstallerClient {
	return &installerClient{cc}
}

func (c *installerClient) InstallPostgres(ctx context.Context, in *InstallPostgresParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Installer_InstallPostgres_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *installerClient) InstallStroppy(ctx context.Context, in *InstallStroppyParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Installer_InstallStroppy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstallerServer is the server API for Installer service.
// All implementations must embed UnimplementedInstallerServer
// for forward compatibility.
type InstallerServer interface {
	InstallPostgres(context.Context, *InstallPostgresParams) (*emptypb.Empty, error)
	InstallStroppy(context.Context, *InstallStroppyParams) (*emptypb.Empty, error)
	mustEmbedUnimplementedInstallerServer()
}

// UnimplementedInstallerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInstallerServer struct{}

func (UnimplementedInstallerServer) InstallPostgres(context.Context, *InstallPostgresParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallPostgres not implemented")
}
func (UnimplementedInstallerServer) InstallStroppy(context.Context, *InstallStroppyParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallStroppy not implemented")
}
func (UnimplementedInstallerServer) mustEmbedUnimplementedInstallerServer() {}
func (UnimplementedInstallerServer) testEmbeddedByValue()                   {}

// UnsafeInstallerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstallerServer will
// result in compilation errors.
type UnsafeInstallerServer interface {
	mustEmbedUnimplementedInstallerServer()
}

func RegisterInstallerServer(s grpc.ServiceRegistrar, srv InstallerServer) {
	// If the following call pancis, it indicates UnimplementedInstallerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Installer_ServiceDesc, srv)
}

func _Installer_InstallPostgres_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallPostgresParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallerServer).InstallPostgres(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Installer_InstallPostgres_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallerServer).InstallPostgres(ctx, req.(*InstallPostgresParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Installer_InstallStroppy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallStroppyParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallerServer).InstallStroppy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Installer_InstallStroppy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallerServer).InstallStroppy(ctx, req.(*InstallStroppyParams))
	}
	return interceptor(ctx, in, info, handler)
}

// Installer_ServiceDesc is the grpc.ServiceDesc for Installer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Installer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hatchet.Installer",
	HandlerType: (*InstallerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InstallPostgres",
			Handler:    _Installer_InstallPostgres_Handler,
		},
		{
			MethodName: "InstallStroppy",
			Handler:    _Installer_InstallStroppy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hatchet/tasks.proto",
}

const (
	Runner_RunStroppy_FullMethodName = "/hatchet.Runner/RunStroppy"
)

// RunnerClient is the client API for Runner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RunnerClient interface {
	RunStroppy(ctx context.Context, in *RunStroppyParams, opts ...grpc.CallOption) (*RunStroppyResponse, error)
}

type runnerClient struct {
	cc grpc.ClientConnInterface
}

func NewRunnerClient(cc grpc.ClientConnInterface) RunnerClient {
	return &runnerClient{cc}
}

func (c *runnerClient) RunStroppy(ctx context.Context, in *RunStroppyParams, opts ...grpc.CallOption) (*RunStroppyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunStroppyResponse)
	err := c.cc.Invoke(ctx, Runner_RunStroppy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServer is the server API for Runner service.
// All implementations must embed UnimplementedRunnerServer
// for forward compatibility.
type RunnerServer interface {
	RunStroppy(context.Context, *RunStroppyParams) (*RunStroppyResponse, error)
	mustEmbedUnimplementedRunnerServer()
}

// UnimplementedRunnerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRunnerServer struct{}

func (UnimplementedRunnerServer) RunStroppy(context.Context, *RunStroppyParams) (*RunStroppyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunStroppy not implemented")
}
func (UnimplementedRunnerServer) mustEmbedUnimplementedRunnerServer() {}
func (UnimplementedRunnerServer) testEmbeddedByValue()                {}

// UnsafeRunnerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunnerServer will
// result in compilation errors.
type UnsafeRunnerServer interface {
	mustEmbedUnimplementedRunnerServer()
}

func RegisterRunnerServer(s grpc.ServiceRegistrar, srv RunnerServer) {
	// If the following call pancis, it indicates UnimplementedRunnerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Runner_ServiceDesc, srv)
}

func _Runner_RunStroppy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunStroppyParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).RunStroppy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runner_RunStroppy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).RunStroppy(ctx, req.(*RunStroppyParams))
	}
	return interceptor(ctx, in, info, handler)
}

// Runner_ServiceDesc is the grpc.ServiceDesc for Runner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Runner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hatchet.Runner",
	HandlerType: (*RunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunStroppy",
			Handler:    _Runner_RunStroppy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hatchet/tasks.proto",
}
